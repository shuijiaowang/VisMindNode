
# 已完成
## 组件：
### canvasView.vue
创建一个外层容器，绑定拖拽/滚轮缩放事件.

### canvasContent.vue
创建无限画布（只是很大并非无限）并显示背景网格。 

双击事件：双击画布空白位置创建Text组件。
点击事件：点击画布空白区域取消选中。
框选事件：ctrl+鼠标按下框选

### 通用
useDraggable.js
拖拽事件，mousedown

### titleComponent.vue
创建标题组件。
### MarkdownComponent.vue
创建Markdown组件。

## store
### canvasStore.js
#### 数据存储与加载，（这个是全量的吗）
saveToDB():存储数据有：elementStore.elMap;elementStore.rootIds;viewStore.offsetX/Y,viewStore.scale
loadFromDB():
clearAllData():

#### 标记拖拽事件，用于和点击事件隔离
`isDragEvent`

### useCanvasViewStore
三个核心：`offsetX`，`offsetY`，`scale`
缓存画布和容器宽高，监听窗口大小变化，减少重复dom操作:
`canvasSize`：'.infinite-canvas';`containerSize`:'.canvas-view-wrapper',（这里的dom元素也可以缓存，除了获取宽高外，可能还要进行其他的操作）

### useCanvasAreaStore
窗口对应画布上的位置 : visibleAreaInCanvasBounds
预加载边界：preloadAreaInCanvasBounds
窗口中心的对应画布的点：windowCenterInCanvas，（那这个中心点不就是visibleAreaInCanvasBounds的中心点，这里好像可以相互调用？不用重复计算）
定时收缩预加载边界防止：shrinkTimer
判断元素是否在预加载边界：isInVisibleArea

### useCanvasMouseStore
mouseClientX，mouseClientY，canvasEl
mousePositionInCanvas:鼠标在画布上的实时坐标，可以拿来调用。

### useCanvasElementStore
elMap:存储所有子元素
rootIds:存储所有
selectedElementIds

## utils
### indexedDB.js
封装indexedDB的常用操作


