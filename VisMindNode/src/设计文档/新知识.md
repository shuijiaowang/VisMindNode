.offsetWidth // 获取元素宽度（）
window.innerWidth //获取浏览器窗口的宽度

backgroundColor: style.backgroundColor || 'transparent', //透明
transition: all 0.2s;//会导致拖拽卡顿

@wheel.stop.passive="false"

transform: `translate(${x}px, ${y}px)`,更好？，确实快了很多

事件的触发顺序：mousedown → mousemove(拖拽时) → mouseup → click
妈的，点击事件注意，


关于你提到的 mouseStore.mousePositionInCanvas 先于 onMounted 执行的问题，这涉及到 Vue 的响应式系统和组件生命周期的执行顺序。让我来解释一下：
响应式数据的初始化时机
mouseStore.mousePositionInCanvas 是一个响应式数据，在组件创建时就已经初始化
它的计算可能依赖于其他响应式数据（如 mouseStore.mouseClientX 和 mouseStore.mouseClientY）
这些基础数据在组件挂载前就已经存在并可以被访问
onMounted 的执行时机
onMounted 钩子在 DOM 挂载完成后执行，但此时响应式数据已经完全初始化
如果 mousePositionInCanvas 是一个计算属性（computed），它会在依赖变化时立即重新计算，而不是等待 onMounted
可能的原因

节流：延迟定时任务，适用于纯数据计算、网络请求
requestAnimationFrame(),浏览器渲染帧同步(16ms),后台标签页或最小化状态时自动暂停节省资源。	适用于涉及 DOM 视觉更新的高频事件（拖拽，滚动、窗口缩放 等情况）